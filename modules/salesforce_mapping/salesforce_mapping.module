<?php

/**
 * @file
 * Manages Salesforce object and Drupal entity mappings.
 */

use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\ReplaceCommand;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\entity\Entity\EntityDisplay;
// Not sure if we'll actually need these, since entity API seems to provide everything:
use Drupal\salesforce_mapping\Entity\SalesforceMapping;
use Drupal\salesforce_mapping\Entity\SalesforceMappingObject;

/**
 * Bit flags defining when a data sync should take place for a given mapping.
 */
define('SALESFORCE_MAPPING_SYNC_OFF', 0x0000);
define('SALESFORCE_MAPPING_SYNC_DRUPAL_CREATE', 0x0001);
define('SALESFORCE_MAPPING_SYNC_DRUPAL_UPDATE', 0x0002);
define('SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE', 0x0004);
define('SALESFORCE_MAPPING_SYNC_SF_CREATE', 0x0008);
define('SALESFORCE_MAPPING_SYNC_SF_UPDATE', 0x0010);
define('SALESFORCE_MAPPING_SYNC_SF_DELETE', 0x0020);

/**
 * Field mapping direction constants.
 */
define('SALESFORCE_MAPPING_DIRECTION_DRUPAL_SF', 'drupal_sf');
define('SALESFORCE_MAPPING_DIRECTION_SF_DRUPAL', 'sf_drupal');
define('SALESFORCE_MAPPING_DIRECTION_SYNC', 'sync');

/**
 * Field mapping Master or no record type (default) constant.
 */
define('SALESFORCE_MAPPING_DEFAULT_RECORD_TYPE', 'default');

/**
 * Delimiter used in Salesforce multipicklists.
 */
define('SALESFORCE_MAPPING_ARRAY_DELIMITER', ';');

/**
 * Field mapping maximum name length.
 */

define('SALESFORCE_MAPPING_NAME_LENGTH', 128);

/**
 * @todo hook_menu is going away, and entity framework no longer builds our menu items. Need this here to expose our routing items to as menus.
 */
function salesforce_mapping_menu() {
  $items = array();

  $items['admin/structure/salesforce/mappings'] = array(
    'title' => 'Salesforce Mappings',
    'description' => 'Manage Salesforce Mappings.',
    'route_name' => 'salesforce_mapping.list',
  );

  $items['admin/structure/salesforce/mappings/add'] = array(
    'title' => 'Add Salesforce Mapping',
    'description' => 'Add Salesforce Mapping',
    'route_name' => 'salesforce_mapping.add',
  );

  $items['admin/structure/salesforce/mappings/%'] = array(
    'title' => 'Properties',
    'route_name' => 'salesforce_mapping.edit',
    // 'type' => MENU_LOCAL_TASK,
    // 'context' => MENU_CONTEXT_INLINE,
  );

  $items['admin/structure/salesforce/mappings/%/fields'] = array(
    'title' => 'Fields',
    'description' => 'Salesforce Mapping Fields',
    'route_name' => 'salesforce_mapping.fields',
  );

  return $items;
}

/**
 * Loads a single salesforce_mapping or all of them if no name provided.
 *
 * @param string $name (optional)
 *   Name of the map to load, or NULL to load all
 * @param bool $reset (optional)
 *   Whether to reset the sf mapping storage controller cache. N/A if $name is
 *   not provided. If a caller needs to reset the *entire* cache, they should do
 *   so explicitly.
 *
 * @return array | SalesforceMapping
 *   The requested mapping or an array of all mappings, indexed by id, if $name
 *   was not specified
 */
function salesforce_mapping_load($name = NULL, $reset = FALSE) {
  if ($name) {
    return entity_load('salesforce_mapping', $name, $reset);
  }
  return entity_load_multiple('salesforce_mapping');
}

/**
 * Loads multiple salesforce_mappings based on a set of matching conditions.
 *
 * @param array $properties (optional)
 *   An array of properties on the {salesforce_mapping} table in the form
 *     'field' => $value.
 *   If $properties is empty, return an all mappings.
 *
 * Note, entity_load_multiple_by_properties() does not provide a reset
 * parameter, and neither do we. If clearing the entire salesforce mapping cache
 * is necessary, it should be done explicitly by the caller.
 *
 * @return array
 *   An array of SalesforceMapping objects,
 *   indexed by id
 */
function salesforce_mapping_load_multiple($properties = array()) {
  if (empty($properties)) {
    return entity_load_multiple('salesforce_mapping');
  }
  return entity_load_multiple_by_properties('salesforce_mapping', $properties);
}

/**
 * Loads salesforce_mappings based on entity type.
 *
 * @param string (optional)
 *   If provided, a single entity type by which to load salesforce_mapping
 *   objects. If empty, return all salesforce mappings, by entity type.
 *
 * @param bool $reset (optional)
 *   Whether to reset the drupal_static cache for this function. If a caller
 *   needs to reset the entire salesforce_mapping storage controller cache, they
 *   must do so explicitly.
 *
 * @return array
 *   An array of SalesforceMapping objects for the given entity_type, or an
 *   array of all SalesforceMapping objects indexed by entity_type, or an
 *   empty array if no maps were found.
 */
function salesforce_mapping_load_by_drupal($entity_type = null, $reset = FALSE) {
  // Use a local static cache since this is not a pass-thru function.
  if ($reset) {
    drupal_static_reset(__FUNCTION__);
  }
  $return = &drupal_static(__FUNCTION__);
  if (!isset($return)) {
    // Just load all the maps and build the static cache all at once. Maps are
    // configuration, which means callers should expect all of them may be
    // loaded on any given pageload.
    $maps = salesforce_mapping_load_multiple();
    $return = array();
    foreach ($maps as $map) {
      $type = $map->get('drupal_entity_type');
      if (!isset($return[$type])) {
        $return[$type] = array();
      }
      $return[$type][$map->id()] = $map;
    }
  }
  // Use if/else instead of ternary operator to avoid PHP undefined index notice
  if ($entity_type) {
    return isset($return[$entity_type]) ? $return[$entity_type] : array();
  }
  return $return;
}

/**
 * Returns Salesforce object mappings for a given Drupal entity.
 *
 * @param string $entity_type
 *   Type of entity to load.
 * @param int $entity_id
 *   Unique identifier of the target entity to load.
 * @param bool $all (optional)
 *   If TRUE, return all object mappings if more than one. Otherwise, return 
 *   only the first. Default FALSE.
 *
 * @return bool | array | salesforce_mapping_object 
 *   The requested salesforce_mapping_object, or array of
 *   salesforce_mapping_objects, or FALSE if none was found.
 * @see SalesforceMappingObject
 */
function salesforce_mapping_object_load_by_drupal($entity_type, $entity_id, $all = FALSE) {
  $properties = array(
    'entity_id' => $entity_id,
    'entity_type' => $entity_type,
  );
  $results = entity_load_multiple_by_properties('salesforce_mapping_object', $properties);
  if (empty($results)) {
    return FALSE;
  }
  return $all ? $results : reset($results);
}

/**
 * Return Salesforce object mappings for a given Salesforce object.
 *
 * @param string $salesforce_id
 *   Unique Id provided by Salesforce for the Salesforce record.
 *
 * @see salesforce_mapping_load() for notes about $reset param being removed.
 *
 * @return array
 *   Entities that match the given $salesforce_id.
 */
function salesforce_mapping_object_load_by_sfid($salesforce_id) {
  $conditions = array('salesforce_id' => $salesforce_id);
  $results = entity_load_multiple_by_properties('salesforce_mapping_object', $conditions);
  return !empty($results) ? reset($results) : FALSE;
}

/**
 * Return a unique list of mapped Salesforce object types.
 *
 * @TODO: add parameter to limit by trigger: http://drupal.org/node/1915668
 */
function salesforce_mapping_get_mapped_objects() {
  $object_types = array();
  $mappings = salesforce_mapping_load();
  usort($mappings, 'salesforce_mapping_sort');
  foreach ($mappings as $mapping) {
    $object_types[$mapping->salesforce_object_type] = $mapping->salesforce_object_type;
  }
  return $object_types;
}

/**
 * Sort mappings by weight.
 */
function salesforce_mapping_sort($mapping_a, $mapping_b) {
  if ($mapping_a->weight == $mapping_b->weight) {
    return 0;
  }
  return ($mapping_a->weight < $mapping_b->weight) ? -1 : 1;
}


/**
 * Implements hook_entity_delete().
 */
function salesforce_mapping_entity_delete(EntityInterface $entity) {
  $type = $entity->entityType();
  // Delete any Salesforce object mappings with this entity.
  $entity_id = $entity->id();
  $bundle = $entity->bundle();
  $mapping_object = salesforce_mapping_object_load_by_drupal($type, $entity_id);

  // No mapping object for this entity, return.
  if (!$mapping_object) {
    return;
  }

  // Only delete mapping if it won't be handled by the delete trigger in the
  // mapping. We're avoiding the issue of mapping deleting the (the what?).
  $mappings = salesforce_mapping_load_multiple(array(
    'drupal_entity_type' => $type,
    'drupal_bundle' => $bundle,
  ));

  foreach ($mappings as $mapping) {
    if (!($mapping->sync_triggers & SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE)) {
      $mapping_object->delete();
      return;
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function salesforce_mapping_entity_load($entities, $entity_type) {
  if ($entity_type == 'salesforce_mapping') {
    // Best to avoid infinite recursion...
    return;
  }
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['maps'] = &drupal_static(__FUNCTION__);
  }
  $maps = &$drupal_static_fast['maps'];

  if (empty($maps)) {
    $maps = salesforce_mapping_load_by_drupal();
  }
  if (!isset($maps[$entity_type])) {
    return;
  }
  foreach ($entities as $entity) {
    $entity_id = $entity->id();
    $mapping = salesforce_mapping_object_load_by_drupal($entity_type, $entity_id);
    if ($mapping) {
      $entity->salesforce_id = $mapping->salesforce_id;
    }
  }
}

/**
 * Implements hook_permission().
 */
function salesforce_mapping_permission() {
  return array(
    'administer salesforce mapping' => array(
      'title' => t('Administer Salesforce mapping'),
      'description' => t('Administer Salesforce field maps.'),
      'restrict access' => TRUE,
    ),
    'view salesforce mapping' => array(
      'title' => t('View Salesforce mapping'),
      'description' => t('View Salesforce mapping data.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_entity_view().
 */
function salesforce_mapping_entity_view(EntityInterface $entity, EntityDisplay $display, $view_mode, $langcode) {
  // Don't bother with any further processing if there are no map for this
  // entity type.
  if (!salesforce_mapping_load_by_drupal($entity->entityType())) {
    return;
  }
  // Render linked Salesforce data when viewing a mapped entity.
  $entity_id = $entity->id();
  $mapping = salesforce_mapping_object_load_by_drupal($entity->entityType(), $entity_id);

  if ($mapping && Drupal::currentUser()->hasPermission('view salesforce mapping')) {
    $sfapi = salesforce_get_api();
    $entity->content['salesforce_id'] = array(
      // '#theme' => 'salesforce_mapping_linked_object',
      '#title' => t('Salesforce ID'),
      '#type' => 'item',
      '#markup' => l(
        $mapping->salesforce_id->value,
        $sfapi->getInstanceUrl() . '/' . $mapping->salesforce_id->value,
        array(
          'attributes' => array('target' => '_blank'),
        )
      ),
      '#classes' => 'field field-label-inline clearfix',
    );
    $entity->content['salesforce_last_sync'] = array(
      // '#theme' => 'salesforce_mapping_linked_object',
      '#title' => t('Salesforce last sync'),
      '#type' => 'item',
      '#markup' => format_date($mapping->last_sync->value),
      '#classes' => 'field field-label-inline clearfix',
    );
  }
}

/**
 * Implements hook_field_extra_fields().
 */
// function salesforce_mapping_field_extra_fields() {
//   // Include Salesforce data for mapped entities.
//   $mappings = salesforce_mapping_load();
//   foreach ($mappings as $mapping) {
//     $extra[$mapping->drupal_entity_type][$mapping->drupal_bundle] = array(
//       'display' => array(
//         'salesforce_id' => array(
//           'label' => t('Salesforce Id'),
//           'description' => t('ID of a linked Salesforce object.'),
//           'weight' => 0,
//         ),
//         'salesforce_last_sync' => array(
//           'label' => t('Salesforce last sync'),
//           'description' => t('Timestamp for the latest sync with Salesforce.'),
//           'weight' => 0,
//         ),
//       ),
//     );
//   }
// 
//   return isset($extra) ? $extra : array();
// }

/**
 * Wrapper around theme_field() to format linked Salesforce data.
 */
function theme_salesforce_mapping_linked_object($variables) {
  return theme_field($variables);
}

/**
 * Implements hook_entity_update().
 *
 * Ensures drupal entity has an update timestamp.
 */
// function salesforce_mapping_entity_update($entity, $type) {
//   // Check if mapping exists.
//   $sf_mappings = salesforce_mapping_load_multiple(array('drupal_entity_type' => $type));
//   if ($sf_mappings) {
//     list($entity_id) = entity_extract_ids($type, $entity);
//     $sf_mapping_object = salesforce_mapping_object_load_by_drupal($type, $entity_id);
//     if ($sf_mapping_object) {
//       // Update entity update property.
//       $sf_mapping_object->entity_updated = REQUEST_TIME;
//       $sf_mapping_object->save();
//     }
//   }
// }

/**
 * Get the Salesforce fieldmap types array.
 *
 * @see hook_salesforce_mapping_fieldmap_type()
 * @see hook_salesforce_mapping_fieldmap_type_alter()
 *
 * @param string $fieldmap_type
 *   The fieldmap type, e.g. property, for which the info shall be returned, or
 *   NULL to return an array with info about all types.
 */
function salesforce_mapping_get_fieldmap_types($fieldmap_type = NULL) {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['salesforce_fieldmap_type'] = & drupal_static(__FUNCTION__);
  }
  $salesforce_fieldmap_type = & $drupal_static_fast['salesforce_fieldmap_type'];

  if (empty($salesforce_fieldmap_type)) {
    if ($cache = cache()->get('salesforce:fieldmap_type')) {
      $salesforce_fieldmap_type = $cache->data;
    }
    else {
      $salesforce_fieldmap_type = module_invoke_all('salesforce_mapping_fieldmap_type');

      // Let other modules alter the fieldmap type.
      drupal_alter('salesforce_fieldmap_type', $salesforce_fieldmap_type);
      cache()->set('salesforce:fieldmap_type', $salesforce_fieldmap_type, CacheBackendInterface::CACHE_PERMANENT, array('salesforce' => TRUE));

    }
  }

  if (empty($fieldmap_type)) {
    return $salesforce_fieldmap_type;
  }
  elseif (isset($salesforce_fieldmap_type[$fieldmap_type])) {
    return $salesforce_fieldmap_type[$fieldmap_type];
  }
}

