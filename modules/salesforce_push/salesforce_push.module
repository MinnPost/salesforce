<?php

/**
 * @file
 * Push updates to Salesforce when a Drupal entity is updated.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\salesforce_mapping\Entity\MappedObject;
use Drupal\salesforce_mapping\Entity\MappedObjectInterface;
use Drupal\salesforce_mapping\Entity\SalesforceMapping;
use Drupal\salesforce_mapping\Entity\SalesforceMappingInterface;
use GuzzleHttp\Exception\RequestException;

/**
 * Implements hook_entity_insert().
 */
function salesforce_push_entity_insert(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_CREATE);
}

/**
 * Implements hook_entity_update().
 */
function salesforce_push_entity_update(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_UPDATE);
}

/**
 * Implements hook_entity_delete().
 */
function salesforce_push_entity_delete(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE);
}

function salesforce_push_salesforce_push_entity_allowed(EntityInterface $entity, $op) {
  // Don't allow mapped objects or mappings to be pushed!
  // @TODO can we implement this instead with a validation constraint? This is fugly.
  if ($entity instanceof MappedObjectInterface 
  || $entity instanceof SalesforceMappingInterface) {
    return FALSE;
  }
}

/**
 * Push entities to Salesforce.
 *
 * @param EntityInterface $entity
 *   The entity object.
 * @param string $op
 *   The trigger being responded to.
 *   One of push_create, push_update, push_delete.
 * @TODO
 *   at some point all these hook_entity_* implementations will go away. We'll
 *   create an event subscriber class to respond to entity events and delegate
 *   actions to the appropriate Push procedures. Unfortunately this point seems 
 *   to be a very long ways away. https://www.drupal.org/node/2551893
 */
function salesforce_push_entity_crud(EntityInterface $entity, $op) {

  try {
    $mappings = salesforce_mapping_load_by_drupal($entity->getEntityTypeId());
  }
  catch (Exception $e) {
    // No mappings found for this entity. We're done.
    return;
  }

  foreach ($mappings as $mapping) {
    $mapped_objects = [];
    $mapped_object = FALSE;
    if (!$mapping->doesCrud([$op])) {
      continue;
    }
    // @TODO decide whether this hook is worth moving to Events framework, and how. Should subscribers throw an exception to prevent entity sync? Return false, like so? Something else entirely?
    foreach (\Drupal::moduleHandler()->invokeAll('salesforce_push_entity_allowed', array($entity, $op, $mapping)) as $value) {
      if ($value === FALSE) {
        continue 2;
      }
    }

    // @TODO batch vs. real-time logic goes here.

    try {
      $mapped_object = salesforce_push_sync_rest($entity, $mapping, $op);
    }
    catch (Exception $e) {
      // what do do here?
    }
  }
}

/**
 * Worker function to do actual push to Salesforce.
 *
 * @param EntityInterface $entity
 * @param SalesforceMappingInterface $mapping
 * @param string $op
 *   one of push_create, push_update, push_delete
 * @return SF result
 *
 * @throws Exception if mapping object cannot be loaded or created
 * @throws RequestException if push operations fail
 */
function salesforce_push_sync_rest(EntityInterface $entity, SalesforceMappingInterface $mapping, $op) {

  // First, look for existing mapped object.
  $props = [
    'entity_id' => $entity->id(),
    'entity_type_id' => $entity->getEntityTypeId(),
    'salesforce_mapping' => $mapping->id(),
  ];
  try {
    $mapped_objects = salesforce_mapped_object_load_multiple($props);
    // There should really only be one, but the return value is always an array
    $mapped_object = current($mapped_objects);
  }
  catch (Exception $e) {
    // No mappings found, need to create a new one and push...
    if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      // Unless it's a delete. Then we're done.
      throw $e;
    }
    $mapped_object = new MappedObject([
      'entity_id' => [LanguageInterface::LANGCODE_DEFAULT => $entity->id()],
      'entity_type_id' => [LanguageInterface::LANGCODE_DEFAULT => $entity->getEntityTypeId()],
      'salesforce_mapping' => [LanguageInterface::LANGCODE_DEFAULT => $mapping->id()],
    ]);
  }

  try {
    // If this is a delete, destroy the SF object and we're done.
    if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      return $mapped_object->pushDelete();
    }
    else {
      // Push to SF. This also saves the mapped object.
      return $mapped_object->push();
    }
  }
  catch (RequestException $e) {
    $mapped_object
      ->set('last_sync_action', $op)
      ->set('last_sync_status', FALSE)
      ->set('last_sync_message', $e->getMessage())
      ->save();
    throw $e;

    // @TODO Can we pawn this off to an entity_save hook? implementations can look at last_sync_status to determine success vs failure.
    // \Drupal::moduleHandler()->invokeAll('salesforce_push_failure', array($e->getMessage(), $vars));
  }
}

/**
 * Implements hook_cron().
 */
function salesforce_push_cron() {
  // @TODO haven't started work on this queue yet.
  return;

  $sfapi = salesforce_get_api();
  if (!$sfapi->isAuthorized()) {
    return;
  }

  $maps = salesforce_mapping_load_multiple();
  $entity_ids = [];
  // General approach to processing the queue:
  // For each map, sorted by weight
  // -- For each operation, delete, create, then update
  // -- -- Build a list of sf params and send it

  $queue = \Drupal::queue('salesforce_push');
  // @TODO SOAP put limit is 200 per op. Why does this default to 50?
  $limit = \Drupal::state()->get('salesforce.push_limit', 50);
  $use_soap = \Drupal::moduleHandler()->moduleExists('salesforce_soap');
  for ($delta = 0; $delta < $limit; $delta++) {
    $item = $queue->claimItem();
    // We do this after the "for()" so that when we reach the limit, we don't
    // incidentally claim a queue license on an item we aren't going to process.
    if (!$item) {
      break;
    }
    $mapping = salesforce_mapping_load($item->data['mapping_id']);

    // Duplicate entity in the queue.
    if ($item->data['entity_type'] == $entity_type && $item->data['entity_id'] == $entity_id) {
      $queue->deleteItem($item);
      continue;
    }

    $entity_type = $item->data['entity_type'];
    $entity_id = $item->data['entity_id'];
    $entity = entity_load($entity_type, $entity_id);
    $mapped_object = salesforce_mapped_object_load_by_entity($entity);
    if ($use_soap) {
      if ($item->data['trigger'] == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE && $mapped_object) {
        $delete_list[$delta] = $mapped_object->salesforce_id;
      }
      else {
        $wrapper = entity_metadata_wrapper($item->data['entity_type'], $entity);
        $params = salesforce_push_map_params($mapping, $wrapper, $key_field, $key_value);

        $synced_entities[$delta] = [
          'entity_wrapper' => $wrapper,
          'mapped_objects' => $mapped_object,
        ];

        $sobject = new stdClass();
        $sobject->type = $mapping->salesforce_object_type;
        foreach ($params as $key => $value) {
          $sobject->fields[$key] = $value;
        }

        if ($mapped_object && $mapped_object->salesforce_id) {
          $sobject->Id = $mapped_object->salesforce_id;
          $update_list[$delta] = $sobject;
        }
        else {
          if ($key_field && $key_value) {
            $upsert_list[$key_field][$delta] = $sobject;
          }
          else {
            $create_list[$delta] = $sobject;
          }
        }
      }
    }
    else {
      salesforce_push_sync_rest($entity_type, $entity, $mapping, $item->data['trigger']);
    }

    // Remove item from queue.
    $queue->deleteItem($item);
  }

  // Use soap API to batch process records.
  if ($use_soap) {
    module_load_include('inc', 'salesforce_soap');
    $soap = new SalesforceSoapPartner($sfapi);
    if (!empty($delete_list)) {
      $results = $soap->delete($delete_list);
      salesforce_push_process_soap_results('Delete', $results, $synced_entities);
    }

    if (!empty($create_list)) {
      $results = $soap->create($create_list);
      salesforce_push_process_soap_results('Create', $results, $synced_entities);
    }

    if (!empty($update_list)) {
      $results = $soap->update($update_list);
      salesforce_push_process_soap_results('Update', $results, $synced_entities);
    }

    if (!empty($upsert_list)) {
      foreach ($upsert_list as $key => $upsert_item) {
        $results = $soap->upsert($key, $upsert_item);
        salesforce_push_process_soap_results('Upsert', $results, $synced_entities);
      }
    }
  }
}
