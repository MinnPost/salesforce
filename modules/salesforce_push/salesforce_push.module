<?php

/**
 * @file
 * Push updates to Salesforce when a Drupal entity is updated.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\salesforce_mapping\Entity;

/**
 * Implements hook_entity_insert().
 */
function salesforce_push_entity_insert(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_CREATE);
}

/**
 * Implements hook_entity_update().
 */
function salesforce_push_entity_update(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_UPDATE);
}

/**
 * Implements hook_entity_delete().
 */
function salesforce_push_entity_delete(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE);
}

function salesforce_push_salesforce_push_entity_allowed(EntityInterface $entity, $op) {
  // Don't allow mapped objects or mappings to be pushed!
  // @TODO can we implement this instead with a validation constraint? This is fugly.
  if ($entity instanceof MappedObjectInterface 
  || $entity instanceof SalesforceMappingInterface) {
    return FALSE;
  }
}

/**
 * Push entities to Salesforce.
 *
 * @param object $entity
 *   The entity object.
 * @param int $op
 *   The trigger being responded to.
 *   One of push_create, push_update, push_delete.
 * @TODO
 *   at some point all these hook_entity_* implementations will go away. We'll
 *   create an event subscriber class to respond to entity events and delegate
 *   actions to the appropriate Push procedures.
 */
function salesforce_push_entity_crud(EntityInterface $entity, $op) {

  // @TODO decide whether this hook is worth moving to Events framework, and how. Should subscribers throw an exception to prevent entity sync? Return false, like so? Something else entirely?
  foreach (\Drupal::moduleHandler()->invokeAll('salesforce_push_entity_allowed', array($entity, $op)) as $value) {
    if ($value === FALSE) {
      return;
    }
  }

  try {
    $mappings = salesforce_mapping_load_by_drupal($entity->getEntityTypeId());
  }
  catch (Exception $e) {
    // No mappings found for this entity. We're done.
    return;
  }

  foreach ($mappings as $mapping) {
    $mapped_objects = [];
    $mapped_object = FALSE;
    if (!$mapping->doesCrud([$op])) {
      continue;
    }

    try {
      $props = [
        'entity_id' => $entity->id(),
        'entity_type_id' => $entity->getEntityTypeId(),
        'salesforce_mapping' => $mapping->id(),
      ];
      $mapped_objects = salesforce_mapped_object_load_multiple($props);
      // There should really only be one, but the return value is always an array
      $mapped_object = current($mapped_objects);

      if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
        // If this is a delete, destroy the mapped object and we're done.
        $mapped_object->pushDelete();
        continue;
      }
    }
    catch (Exception $e) {
      // No mappings found, need to create a new one and push...

      if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
        // Unless it's a delete. Then we're done.
        continue;
      }
      $mapped_object = new MappedObject([
        'entity_id' => [LanguageInterface::LANGCODE_DEFAULT => $entity->id()],
        'entity_type_id' => [LanguageInterface::LANGCODE_DEFAULT => $entity->getEntityTypeId()],
        'salesforce_mapping' => [LanguageInterface::LANGCODE_DEFAULT => $mapping->id()],
      ]);
    }

    try {
      // Push to SF. This also saves the mapped object.
      $result = $mapped_object->push();
      // Do something with the result?
    }
    catch (Exception $e) {
      // @TODO As long as push is handled in MappedObject, this hook invocation should go there. We're only handling this exception so that we don't block the entity CRUD operation.
      continue;

      // $vars = [
      //   'entity' => $entity,
      //   'mapping' => $mapping,
      //   'params' => $params,
      //   'exception' => $e,
      //   'op' => $op,
      // ];
      //
      // // @TODO This should definitely be an event. See SalesforceEvents::PUSH_FAIL
      // \Drupal::moduleHandler()->invokeAll('salesforce_push_failure', array($e->getMessage(), $vars));
    }
  }


}

/**
 * Implements hook_cron().
 */
function salesforce_push_cron() {
  // @TODO haven't started work on this queue yet.
  return;

  $sfapi = salesforce_get_api();
  if (!$sfapi->isAuthorized()) {
    return;
  }

  $maps = salesforce_mapping_load_multiple();
  $entity_ids = [];
  // General approach to processing the queue:
  // For each map, sorted by weight
  // -- For each operation, delete, create, then update
  // -- -- Build a list of sf params and send it

  $queue = \Drupal::queue('salesforce_push');
  // @TODO SOAP put limit is 200 per op. Why does this default to 50?
  $limit = \Drupal::state()->get('salesforce.push_limit', 50);
  $use_soap = \Drupal::moduleHandler()->moduleExists('salesforce_soap');
  for ($delta = 0; $delta < $limit; $delta++) {
    $item = $queue->claimItem();
    // We do this after the "for()" so that when we reach the limit, we don't
    // incidentally claim a queue license on an item we aren't going to process.
    if (!$item) {
      break;
    }
    $mapping = salesforce_mapping_load($item->data['mapping_id']);

    // Duplicate entity in the queue.
    if ($item->data['entity_type'] == $entity_type && $item->data['entity_id'] == $entity_id) {
      $queue->deleteItem($item);
      continue;
    }

    $entity_type = $item->data['entity_type'];
    $entity_id = $item->data['entity_id'];
    $entity = entity_load($entity_type, $entity_id);
    $mapped_object = salesforce_mapped_object_load_by_entity($entity);
    if ($use_soap) {
      if ($item->data['trigger'] == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE && $mapped_object) {
        $delete_list[$delta] = $mapped_object->salesforce_id;
      }
      else {
        $wrapper = entity_metadata_wrapper($item->data['entity_type'], $entity);
        $params = salesforce_push_map_params($mapping, $wrapper, $key_field, $key_value);

        $synced_entities[$delta] = [
          'entity_wrapper' => $wrapper,
          'mapped_objects' => $mapped_object,
        ];

        $sobject = new stdClass();
        $sobject->type = $mapping->salesforce_object_type;
        foreach ($params as $key => $value) {
          $sobject->fields[$key] = $value;
        }

        if ($mapped_object && $mapped_object->salesforce_id) {
          $sobject->Id = $mapped_object->salesforce_id;
          $update_list[$delta] = $sobject;
        }
        else {
          if ($key_field && $key_value) {
            $upsert_list[$key_field][$delta] = $sobject;
          }
          else {
            $create_list[$delta] = $sobject;
          }
        }
      }
    }
    else {
      salesforce_push_sync_rest($entity_type, $entity, $mapping, $item->data['trigger']);
    }

    // Remove item from queue.
    $queue->deleteItem($item);
  }

  // Use soap API to batch process records.
  if ($use_soap) {
    module_load_include('inc', 'salesforce_soap');
    $soap = new SalesforceSoapPartner($sfapi);
    if (!empty($delete_list)) {
      $results = $soap->delete($delete_list);
      salesforce_push_process_soap_results('Delete', $results, $synced_entities);
    }

    if (!empty($create_list)) {
      $results = $soap->create($create_list);
      salesforce_push_process_soap_results('Create', $results, $synced_entities);
    }

    if (!empty($update_list)) {
      $results = $soap->update($update_list);
      salesforce_push_process_soap_results('Update', $results, $synced_entities);
    }

    if (!empty($upsert_list)) {
      foreach ($upsert_list as $key => $upsert_item) {
        $results = $soap->upsert($key, $upsert_item);
        salesforce_push_process_soap_results('Upsert', $results, $synced_entities);
      }
    }
  }
}
