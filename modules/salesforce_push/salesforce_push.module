<?php

/**
 * @file
 * Push updates to Salesforce when a Drupal entity is updated.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\salesforce_mapping\Entity\MappedObject;
use Drupal\salesforce_mapping\Entity\MappedObjectInterface;
use Drupal\salesforce_mapping\Entity\SalesforceMapping;
use Drupal\salesforce_mapping\Entity\SalesforceMappingInterface;
use GuzzleHttp\Exception\RequestException;

/**
 * Implements hook_entity_insert().
 */
function salesforce_push_entity_insert(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_CREATE);
}

/**
 * Implements hook_entity_update().
 */
function salesforce_push_entity_update(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_UPDATE);
}

/**
 * Implements hook_entity_delete().
 */
function salesforce_push_entity_delete(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE);
}

function salesforce_push_salesforce_push_entity_allowed(EntityInterface $entity, SalesforceMappingInterface $mapping, $op) {
  // Don't allow mapped objects or mappings to be pushed!
  // @TODO can we implement this instead with a validation constraint? This is fugly.
  if ($entity instanceof MappedObjectInterface
  || $entity instanceof SalesforceMappingInterface) {
    return FALSE;
  }
}

/**
 * Push entities to Salesforce.
 *
 * @param EntityInterface $entity
 *   The entity object.
 * @param string $op
 *   The trigger being responded to.
 *   One of push_create, push_update, push_delete.
 * @TODO
 *   at some point all these hook_entity_* implementations will go away. We'll
 *   create an event subscriber class to respond to entity events and delegate
 *   actions to the appropriate Push procedures. Unfortunately this point seems
 *   to be a very long ways away. https://www.drupal.org/node/2551893
 */
function salesforce_push_entity_crud(EntityInterface $entity, $op) {
  $mappings = salesforce_push_load_push_mappings($entity->getEntityTypeId());
  foreach ($mappings as $mapping) {
    $mapped_objects = [];
    $mapped_object = FALSE;
    // @TODO decide whether this hook is worth moving to Events framework, and how. Should subscribers throw an exception to prevent entity sync? Return false, like so? Something else entirely?
    foreach (\Drupal::moduleHandler()->invokeAll('salesforce_push_entity_allowed', array($entity, $mapping, $op)) as $value) {
      if ($value === FALSE) {
        continue 2;
      }
    }

    if ($mapping->async) {
      // Enqueue
      salesforce_push_enqueue_async($entity, $mapping, $op);
      return;
    }

    try {
      $mapped_object = salesforce_push_sync_rest($entity, $mapping, $op);
    }
    catch (Exception $e) {
      // what do do here?
    }
  }
}

/**
 * Helper function to load only those mappings which have at least one push
 * trigger enabled.
 *
 * @param $entity_type_id
 *   (optional) filter by mapping drupal entity type.
 *
 * @return array
 */
function salesforce_push_load_push_mappings($entity_type_id = NULL) {
  $push_mappings = [];
  try {
    $properties = empty($entity_type_id)
      ? []
      : ["drupal_entity_type" => $entity_type_id];
    $mappings = salesforce_mapping_load_multiple($properties);
    foreach ($mappings as $key => $mapping) {
      if (!$mapping->doesPush()) {
        continue;
      }
      $push_mappings[$key] = $mapping;
    }
  }
  catch (Exception $e) {
    // No mappings found.
  }
  return $push_mappings;
}

/**
 * Worker function to do actual push to Salesforce.
 *
 * @param EntityInterface $entity
 * @param SalesforceMappingInterface $mapping
 * @param string $op
 *   one of push_create, push_update, push_delete
 * @return SF result
 *
 * @throws Exception if mapping object cannot be loaded or created
 * @throws RequestException if push operations fail
 */
function salesforce_push_sync_rest(EntityInterface $entity, SalesforceMappingInterface $mapping, $op) {

  // First, look for existing mapped object.
  $props = [
    'entity_id' => $entity->id(),
    'entity_type_id' => $entity->getEntityTypeId(),
    'salesforce_mapping' => $mapping->id(),
  ];
  try {
    $mapped_objects = salesforce_mapped_object_load_multiple($props);
    // There should really only be one, but the return value is always an array
    $mapped_object = current($mapped_objects);
  }
  catch (Exception $e) {
    // No mappings found, need to create a new one and push...
    if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      // Unless it's a delete. Then we're done.
      throw $e;
    }
    $mapped_object = new MappedObject([
      'entity_id' => $entity->id(),
      'entity_type_id' => $entity->getEntityTypeId(),
      'salesforce_mapping' => $mapping->id(),
    ]);
  }

  try {
    // If this is a delete, destroy the SF object and we're done.
    if ($op == SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      return $mapped_object->pushDelete();
    }
    else {
      // Push to SF. This also saves the mapped object.
      return $mapped_object->push();
    }
  }
  catch (RequestException $e) {
    $mapped_object
      ->set('last_sync_action', $op)
      ->set('last_sync_status', FALSE)
      ->set('revision_log_message', $e->getMessage())
      ->save();
    throw $e;

    // @TODO Can we pawn this off to an entity_save hook? implementations can look at last_sync_status to determine success vs failure.
    // \Drupal::moduleHandler()->invokeAll('salesforce_push_failure', array($e->getMessage(), $vars));
  }
}

/**
 * Worker function to insert a new queue item into the async push queue for the
 * given mapping.
 * @param EntityInterface $entity
 * @param SalesforceMappingInterface $mapping
 * @param string $op
 */
function salesforce_push_enqueue_async(EntityInterface $entity, SalesforceMappingInterface $mapping, $op) {
  // Each mapping has its own queue, so that like entries can be easily grouped
  // for batching. Each queue item is a unique array of entity ids to be
  // pushed. The async queue worker loads the queue item and works through as
  // many entities as possible, up to the async limit for this mapping.
  \Drupal::service('queue.salesforce')->createItem([
    'name' => $mapping->id(),
    'entity_id' => $entity->id(),
    'op' => $op,
  ]);
}

/**
 * Implements hook_cron().
 */
function salesforce_push_cron() {
  \Drupal::service('queue.salesforce')->processQueue();
}
