<?php

/**
 * @file
 * Pull updates from Salesforce when a Salesforce object is updated.
 */

use \Drupal\salesforce\SelectQuery;
use \Drupal\salesforce\RestClient;

/**
 * Implements hook_cron().
 */
function salesforce_pull_cron() {
  $sfapi = salesforce_get_api();
  if ($sfapi->isAuthorized()) {
    salesforce_pull_get_updated_records($sfapi);
    salesforce_pull_process_deleted_records($sfapi);
  }
}

/**
 * Pull updated records from Salesforce and place them in the queue.
 *
 * Executes a SOQL query based on defined mappings, loops through the results,
 * and places each updated SF object into the queue for later processing.
 */
function salesforce_pull_get_updated_records(RestClient $sfapi) {
  // @TODO: Refactor all this.
  return;
  $queue = \Drupal::queue('cron_salesforce_pull');

  // Avoid overloading the processing queue and pass this time around if it's
  // over a configurable limit.

  if ($queue->numberOfItems() > \Drupal::state()->get('salesforce_pull_max_queue_size', 100000)) {
    return;
  }

  foreach (salesforce_mapping_get_mapped_objects() as $type) {
    $mapped_fields = [];
    $mapped_record_types = [];

    // Iterate over each field mapping to determine our query parameters.
    foreach (salesforce_mapping_load_multiple(['salesforce_object_type' => $type]) as $mapping) {
      foreach ($mapping->field_mappings as $field_map) {
        // Exclude field mappings that are only drupal to SF.
        if (in_array($field_map['direction'], [SALESFORCE_MAPPING_DIRECTION_SYNC, SALESFORCE_MAPPING_DIRECTION_SF_DRUPAL])) {
          // Some field map types (Relation) store a collection of SF objects.
          if (is_array($field_map['salesforce_field']) && !isset($field_map['salesforce_field']['name'])) {
            foreach ($field_map['salesforce_field'] as $sf_field) {
              $mapped_fields[$sf_field['name']] = $sf_field['name'];
            }
          }
          // The rest of are just a name/value pair.
          else {
            $mapped_fields[$field_map['salesforce_field']] = $field_map['salesforce_field'];
          }
        }
      }

      if (!empty($mapped_fields) && isset($mapping->salesforce_record_type)  && $mapping->salesforce_record_type != SALESFORCE_MAPPING_DEFAULT_RECORD_TYPE) {
        // @TODO: Get this next statement working as indented. See lines 110-112.ÃŸ
        //$mapped_record_types[$mapping->salesforce_record_type] = $mapping->salesforce_record_type;
        // Add the RecordTypeId field so we can use it when processing the
        // queued SF objects.
        //$mapped_fields['RecordTypeId'] = 'RecordTypeId';
      }
    }

    // There are no field mappings configured to pull data from Salesforce so
    // move on to the next mapped object. Prevents querying unmapped data.
    if (empty($mapped_fields)) {
      continue;
    }

    // @TODO figure out the new way to build the query.
    $soql = new SelectQuery($type);
    // Convert field mappings to SOQL.
    $soql->fields = ['Id', 'LastModifiedDate'];
    foreach ($mapped_fields as $field) {
      // Don't add the Id field to the SOQL query.
      if ($field == 'Id') {
        continue;
      }
      $soql->fields[] = $field;
    }

    // If no lastupdate, get all records, else get records since last pull.
    $sf_last_sync = \Drupal::state()->get('salesforce_pull_last_sync_' . $type, NULL);
    if ($sf_last_sync) {
      $last_sync = gmdate('Y-m-d\TH:i:s\Z', $sf_last_sync);
      $soql->addCondition('LastModifiedDate', $last_sync, '>');
    }

    // If Record Type is specified, restrict query.
    if (count($mapped_record_types) > 0) {
      $soql->addCondition('RecordTypeId', $mapped_record_types, 'IN');
    }

    // Execute query.
    $results = $sfapi->query($soql);
    $version_path = parse_url($sfapi->getApiEndPoint(), PHP_URL_PATH);

    if (!isset($results['errorCode'])) {
      // Write items to the queue.
      foreach ($results['records'] as $result) {
        $queue->createItem($result);
      }

      // Handle requests larger than the batch limit (usually 2000).
      $next_records_url = isset($results['nextRecordsUrl']) ?
        str_replace($version_path, '', $results['nextRecordsUrl']) :
        FALSE;
      while ($next_records_url) {
        $new_result = $sfapi->apiCall($next_records_url);
        if (!isset($new_result['errorCode'])) {
          // Write items to the queue.
          foreach ($new_result['records'] as $result) {
            $queue->createItem($result);
          }
        }
        $next_records_url = isset($new_result['nextRecordsUrl']) ?
          str_replace($version_path, '', $new_result['nextRecordsUrl']) : FALSE;
      }

      \Drupal::state()->set('salesforce_pull_last_sync_' . $type, REQUEST_TIME);
    }
    else {
      \Drupal::logger('Salesforce Pull')->error('%code:%msg', [
        '%code' => $results['errorCode'],
        '%msg' => $results['message'],
      ]);
    }
  }
}

/**
 * Process deleted records from salesforce.
 */
function salesforce_pull_process_deleted_records(RestClient $sfapi) {
  // @TODO Add back in SOAP, and use autoloading techniques
  /*
  if (!\Drupal::moduleHandler()->moduleExists('salesforce_soap')) {
    salesforce_set_message('Enable Salesforce SOAP to process deleted records');
    return;
  }
  module_load_include('inc', 'salesforce_soap');
  $soap = new SalesforceSoapPartner($sfapi);
  */
  foreach (array_reverse(salesforce_mapping_get_mapped_objects()) as $type) {

    $last_delete_sync = \Drupal::state()->get('salesforce_pull_delete_last_' . $type, REQUEST_TIME);
    $now = time();
    // SOAP getDeleted() restraint: startDate must be at least one minute
    // greater than endDate.
    $now = $now > $last_delete_sync + 60 ? $now : $now + 60;
    $last_delete_sync_sf = gmdate('Y-m-d\TH:i:s\Z', $last_delete_sync);
    $now_sf = gmdate('Y-m-d\TH:i:s\Z', $now);
    //$deleted = $soap->getDeleted($type, $last_delete_sync_sf, $now_sf);
    $deleted = $sfapi->apiCall(
      "sobjects/$type/deleted/?start=$last_delete_sync_sf&end=$now_sf",
      [],
      'GET'
    );
    // Cast $deleted as object since REST is returning an array instead of
    // the object the SOAP client apparantly does
    $deleted = (object) $deleted;

    if (!empty($deleted->deletedRecords)) {
      $sf_mappings = salesforce_mapping_load_multiple(
        ['salesforce_object_type' => $type]
      );
      foreach ($deleted->deletedRecords as $record) {
        $mapped_object = salesforce_mapped_object_load_by_sfid($record->id);
        if ($mapped_object) {
          $entity = \Drupal::entityTypeManager()
            ->getStorage($mapped_object->entity_type)
            ->load($mapped_object->entity_id);
          foreach ($sf_mappings as $sf_mapping) {
            if ($sf_mapping->sync_triggers & SALESFORCE_MAPPING_SYNC_SF_DELETE) {
              // Delete mapping object.
              $transaction = db_transaction();
              $map_entity = \Drupal::entityTypeManager()
                ->getStorage('salesforce_mapped_object')
                ->load($mapped_object->salesforce_mapped_object_id);
              $map_entity->delete();
              $map_entity = \Drupal::entityTypeManager()
                ->getStorage($sf_mapping->drupal_entity_type)
                ->load($mapped_object->entity_id);
              $map_entity->delete();

              \Drupal::logger('Salesforce Pull')->notice(
                'Deleted entity %label with ID: %id associated with Salesforce Object ID: %sfid',
                [
                  '%label' => $entity->label(),
                  '%id' => $mapped_object->entity_id,
                  '%sfid' => $record->id,
                ]
              );
            }
          }
          $mapped_object->delete();
        }
      }
    }
    \Drupal::state()->set('salesforce_pull_delete_last_' . $type, REQUEST_TIME);
  }
}

/**
 * Map field values.
 *
 * @param array $field_maps
 *   Array of field maps.
 * @param object $entity_wrapper
 *   Entity wrapper object.
 * @param object $sf_object
 *   sObject of the Salesforce record.
 * @TODO this should move into SalesforceMapping.php
 */
function salesforce_pull_map_fields($field_maps, &$entity_wrapper, $sf_object) {
  foreach ($field_maps as $field_map) {
    if ($field_map['direction'] == 'sync' || $field_map['direction'] == 'sf_drupal') {

      $drupal_fields_array = explode(':', $field_map['drupal_field']['fieldmap_value']);
      $parent = $entity_wrapper;
      foreach ($drupal_fields_array as $drupal_field) {
        if ($parent instanceof EntityListWrapper) {
          $child_wrapper = $parent->get(0)->{$drupal_field};
        }
        else {
          $child_wrapper = $parent->{$drupal_field};
        }
        $parent = $child_wrapper;
      }
      $fieldmap_type = salesforce_mapping_get_fieldmap_types($field_map['drupal_field']['fieldmap_type']);
      $value = call_user_func($fieldmap_type['pull_value_callback'], $parent, $sf_object, $field_map);

      // Allow this value to be altered before assigning to the entity.
      drupal_alter('salesforce_pull_entity_value', $value, $field_map, $sf_object);
      if (isset($value)) {
        // @TODO: might wrongly assumes an individual value wouldn't be an
        // array.
        if ($parent instanceof EntityListWrapper && !is_array($value)) {
          $parent->offsetSet(0, $value);
        }
        else {
          $parent->set($value);
        }
      }
    }
  }
}

/**
 * Implements hook_salesforce_push_entity_allowed()
 * Prevent an entity from being re-synched multiple times during one request.
 */
function salesforce_pull_salesforce_push_entity_allowed($entity, $op) {
  return !isset($entity->salesforce_pull) || !$entity->salesforce_pull;
}
